
# This program is to test the effects of environmental factors and dispersal 
# on species area relationship(SAR)


SAR=function(data,nx,plotdim,process="Hom.Po",covr=list(elev=NULL,slope=NULL,aspect=NULL,convex=NULL,dister=NULL), sig.t=FALSE,nsam=100,show.stage=TRUE)
{
###################
#@ nx:  	numeric. The number of sample scale;
#@ plotdim: 	vector. Plotdim[1] is x; plotdim[2] is y;
#@ processes: 	character. All recognized processes are "Real", "Hom.Po", "Ihom.Po", "Hom.Th", "Inhom.Th";
#		"Real":		no theoretical assumption;
#		"Hom.Po":   		 Homogeneous Poisson Process
#		"Inhom.Po":  	 Inhomogeneous Poisson Process
#		"Hom.Th":    	 Homogeneous Thomas Process
#		"Inhom.Th":		 Inhomogeneous Thomas Process.
#@ covr: 	list. Each element is an im object which could be generated by im() 
#               in spatstat package. Each element should have a name;
#@ nsam:	numeric. Repeat times in one sample scale.
#@ show.stage: logical. Print the stage of calculation if true.
####################

alpha=0.05
envelope=FALSE
#include required library
library(spatstat)

#set the windows
win=owin(c(0,plotdim[1]),c(0,plotdim[2]))

#species abundance
n=table(data$sp)
#richness
S=length(n)
# species name
sp=unique(data$sp)

#total area
A0=plotdim[1]*plotdim[2]
#sample area vector
A=exp(seq(1,log(A0),length.out=nx))
#define quadrat shape
qsp=plotdim[2]/plotdim[1]
y=sqrt(qsp*A)
x=y/qsp


## calculate the real SAR
if (process=="Real"){
	result=data.frame()

	for (i in 1:length(A)){
		temp1=plot.sample(data=data,subplot=c(x[i],y[i]),nsam=nsam,plotdim=plotdim)
		result[i,1]=temp1[1]
		result[i,2]=temp1[2]
	}

}else{

## calculate theoretical SAR
if (process=="Hom.Po"){

	result=Hom.Po(n=n,A0=A0,A=A)

}else{

# step 1:, simulate the whole dataset
data.new=data.frame(sp=NA,gx=NA,gy=NA)
distance=vector()
env.sig=matrix(NA, nrow=S, ncol=length(covr))
pars=list()

if (show.stage){
print("The first stage: estimating parameter")
print(paste("The total step in this stage:",S))
}

for (i in 1:S){
	
	sp1=data[which(data$sp==sp[i]),]
	#convert data format and remove duplicated data
	data.ppp=unique(ppp(x=sp1$gx,y=sp1$gy,window=win))
	
	if (process=="Inhom.Po")
	sp1=Inhom.Po(data.ppp,covr=covr,win=win,sig.t=sig.t)
	
	if (process=="Hom.Th")
	sp1=Hom.Th(data.ppp,win=win)
	
	if (process=="Inhom.Th"){
	sp1=Inhom.Th(data.ppp,covr=covr,win=win,sig.t=sig.t,P=alpha)
	
	}
	
	data.new=rbind(data.new,data.frame(sp=rep(sp[i],times=sp1$n),gx=sp1$x,gy=sp1$y))
	
	if (process=="Inhom.Th"){
	#record the distance
	distance[i]=attr(sp1,"distance")
	
	#show stage
	if (show.stage){
	print(i)
	}
	
	#record parameters
	if (envelope){
		pars[[i]]=attr(sp1,"pars")
	}
}
data.new=data.new[-1,]

	#step2: generate SAR
	result=data.frame()
	
	if (show.stage){
		print("second stage: Generate SAR")
		print(paste("total step in this stage:",length(A)))
	}

	for (i in 1:length(A)){
		temp2=plot.sample(data=data.new,subplot=c(x[i],y[i]),nsam=nsam,plotdim=plotdim)
		result[i,1]=temp2[1]
		result[i,2]=temp2[2]
		if (show.stage){
			print(i)
		}
	}
	
	colnames(result)=c("S.mean","S.var")
	if (process=="Inhom.Th"){
		names(distance)=sp
		attr(result,"distance")=distance
		
		if (sig.t){
		colnames(env.sig)=names(covr)
		attr(result,"env.P.value")=env.sig
		}
	}
	
}
}
colnames(result)=c("S.mean","S.var")
result$A=A
attr(result,"process")=process


return(result)
}



# 1. random-placement model or Homogeneous Poisson process

# n: vector of species abundance
# A0: total sample area
# A: vector of sub-region area
Hom.Po=function(n,A0,A){
#N: total number of species
    N=length(n)
	temp1=apply(matrix(A),1,function(x) sum((1-x/A0)^n))
	temp2=apply(matrix(A),1,function(x) sum((1-x/A0)^(n*2)))
	S.mean=N-temp1
    S.var=temp1-temp2
return(data.frame(S.mean,S.var))
}


#simulate inhomogeneous Poisson process

Inhom.Po=function(data.ppp,covr,win,sig.t){

sig=NULL

fu=formu(names(covr))

# using maximum likelihood method to estimate parameter
data.ppm=ppm(data.ppp,fu,covariates=covr)


# simulate species distribution using the above fitted model
re=rmh.ppm(data.ppm)

return(re)
}



# Homogeneous Thomas process

Hom.Th=function(data.ppp,win){


#using CRV process to simulate the process
#and estimate density
	data.ppm=ppm(data.ppp)
	lambda=exp(data.ppm$coef[[1]])


	K=Kest(data.ppp,correction="border")
	
	#pre-hand K result, remove NA in K
	chose=which(!is.na(K$border) & K$border==max(K$border,na.rm=T))[1]
	K=K[1:chose,]
	
	
	#using minimum contrast method to estimate sigma, mu
	Thom=thomas.estK.my(K, c(sigma2=K$r[chose]/4, kappa=1/K$border[chose]),lambda=lambda,maxit=1e+5)
	Thom.par=Thom$modelpar
	
	if (Thom.par[3]<1e-5 | Thom$opt$convergence!=0) re=rmh(data.ppm)
	else re=rThomas.my(kappa=Thom.par[1],sigma=Thom.par[2],mu=Thom.par[3],win=win)
	
	attr(re,"distance")=Thom.par[2]
	
return(re)
}


# inhomogeneous Thomas process


Inhom.Th=function(data.ppp,covr,win,sig.t,P=0.05,simla=TRUE){

sig=rep(NA,times=length(covr))

fu=formu(names(covr))

# using maximum likelihood method to estimate parameter
data.ppm=ppm(data.ppp,fu,covariates=covr)


#estimate density and location density
lambda=predict(data.ppm,ngrid=c(covr[[1]]$dim[1],covr[[1]]$dim[2]))
lambda2=predict(data.ppm,locations=list(x=data.ppp$x,y=data.ppp$y))
	
# calculate inhomogeneous K function
K=Kinhom(data.ppp,lambda2,correction="border")

#pre-hand K result, remove NA in K
chose=which(!is.na(K$border) & K$border==max(K$border,na.rm=T))[1]
K=K[1:chose,]

#using minimum contrast method to estimate sigma, mu
Thom=thomas.estK.my(K, c(sigma2=K$r[chose]/4, kappa=1/K$border[chose]), lambda=lambda, maxit=1e+5 )
Thom.par=Thom$modelpar
print(Thom.par[2])
if (sig.t & Thom.par[2]<=200)
sig=confi.inter(covr,beta=coef(data.ppm),sigma=Thom.par[2],kappa=Thom.par[1],P)

if (simla){
# prepare for thinning process
cst=coef(data.ppm)[1]
lambda.c=lambda
	

M=max(lambda.c$v)
# pre-thinning density of offspring 

Thom.par[3]=M/Thom.par[1]

	if (Thom.par[3]<1e-4 | Thom.par[1]*win$xrange[2]*win$yrange[2] < 1 |Thom.par[3]>1e+4){
		re=rmh(data.ppm)
		while (re$n==0)
			re=rmh(data.ppm)
		
	}else{
		re=rThomas.my(kappa=Thom.par[1],sigma=Thom.par[2],mu=Thom.par[3],win=win)
	while (re$n==0)
		re=rThomas.my(kappa=Thom.par[1],sigma=Thom.par[2],mu=Thom.par[3],win=win)
	
		#thinning process
		lambda.c$v=lambda.c$v/M
		re=rthin(re,lambda.c)
	}
}else{
re=ppp(x=c(1:2),y=c(1:2),window=win)

}
attr(re,"sig")=sig
attr(re,"distance")=Thom.par[2]

return(re)
}


# Formula construct

formu=function(name,del=NULL){
l=length(name)
for (i in 1:l){
	if (i==1) fu=paste("~",name[i])
	else fu=paste(fu,"+",name[i])
}
if (!is.null(del))
fu=paste(fu,del)

fu=as.formula(fu)
return(fu)
}

#adjust windows for covariance
setwin=function(data,covr,plotdim){
n=length(covr)
x.min=x.max=y.min=y.max=numeric()
for (i in 1:n){
	x.min[i]=covr[[i]]$xrange[1]
	x.max[i]=covr[[i]]$xrange[2]
	y.min[i]=covr[[i]]$yrange[1]
	y.max[i]=covr[[i]]$yrange[2]
}
x.max=min(x.max,plotdim[1])
y.max=min(y.max,plotdim[2])
x.min=max(x.min)
y.min=max(y.min)
win=owin(c(x.min,x.max),c(y.min,y.max))
plotdim=c(x.max-x.min,y.max-y.min)

data=data[which(data$gx>=x.min & data$gx<=x.max & data$gy>=y.min & data$gy<=y.max),]
data$gx=data$gx-min(data$gx)
data$gy=data$gy-min(data$gy)

for (i in 1:n){
	covr[[i]]=covr[[i]][win]
	covr[[i]]$xrange=c(0,plotdim[1])
	covr[[i]]$yrange=c(0,plotdim[2])
	covr[[i]]$xcol=covr[[i]]$xcol-x.min
	covr[[i]]$yrow=covr[[i]]$yrow-y.min
}

return(list(plotdim,data,covr))
}

# Soil data transformation
soil.tran=function(soil,url){
library(foreign)
library(spatstat)
n=length(soil)
wd=getwd()
setwd(url)
result=list()
for (i in 1:n){
	da=read.dbf(paste(soil[i],".dbf",sep=""))
	da=matrix(da[,2],nrow=121,ncol=246,byrow=T)
	da=da[sort(1:121,decreasing=T),]
	result[[i]]=im(da,xcol=seq(10,990,by=4),yrow=seq(10,490,by=4))
}
names(result)=soil
setwd(wd)
return(result)
}

# modified rThomas function
rThomas.my=function (kappa, sigma, mu, win = owin(c(0, 1), c(0, 1))) 
{
    stopifnot(is.numeric(sigma) && length(sigma) == 1 && sigma > 
        0)
    stopifnot(is.numeric(mu) && length(mu) == 1 && mu >= 0)
	#new function 1
    thomclus <- function(x0, y0, sigma, mu,n) {
        x <- rnorm(n, mean = x0, sd = sigma)
        y <- rnorm(n, mean = y0, sd = sigma)
        return(list(x = x, y = y))
    }
	#new function 2
	check <- function(n,mu){
		off.n=rpois(n,mu)
		chose=which(off.n>=1)
		off.n=off.n[chose]
		return(list(chose,off.n))
	}
    result <- rNeymanScott.my(kappa, 4 * sigma, thomclus, check ,win, sigma = sigma, 
        mu = mu)
    return(result)
}

#Calculate the modified rNeyman-Scott function; make the function work faster 
# and be capability for large datasets; disable the parent information calculation
rNeymanScott.my=function (kappa, rmax, rcluster, ncluster, win = owin(c(0, 1), c(0, 1)), mu,
    ..., lmax = NULL) 
{
    win <- as.owin(win)
    frame <- bounding.box(win)
    dilated <- owin(frame$xrange + c(-rmax, rmax), frame$yrange + 
        c(-rmax, rmax))
    if (is.im(kappa) && !is.subset.owin(as.owin(kappa), dilated)) 
        stop(paste("The window in which the image", sQuote("kappa"), 
            "is defined\n", "is not large enough to contain the dilation of the window", 
            sQuote("win")))
	total=mean(kappa)*win$xrange[2]*win$yrange[2]	
	if (total<=1e+5){
		parents <- rpoispp.my(kappa, lmax = lmax, win = dilated)
		result <- ppp(numeric(0), numeric(0), window = win)
		parentid <- numeric(0)
		if (parents$n > 0) {
			chose=ncluster(n=parents$n, mu=mu)
			if (length(chose[[1]])>0){
				for (i in 1:length(chose[[1]])) {
					k=chose[[1]][i]
					n=chose[[2]][i]
					cluster <- rcluster(x0=parents$x[k], y0=parents$y[k], n=n, ...)
					chos.off<- which(cluster$x>=win$xrange[1] & cluster$x<=win$xrange[2] 
									& cluster$y>=win$yrange[1] & cluster$y<=win$yrange[2])
					if (i==1) {
						offsp.x=cluster$x[chos.off]
						offsp.y=cluster$y[chos.off]
					}else{
						offsp.x=c(offsp.x,cluster$x[chos.off])
						offsp.y=c(offsp.y,cluster$y[chos.off])
					}
					#parentid <- c(parentid, rep(i, cluster$n))
				}
				result <- ppp(offsp.x, offsp.y, window = frame, check = FALSE)
			}
		}
	}else{
		times=ceiling(total/1e+5)
		kappa=kappa/times
		pp.j=0
		for (j in 1:times){
		parents <- rpoispp.my(kappa, lmax = lmax, win = dilated)
		result <- ppp(numeric(0), numeric(0), window = win)
		parentid <- numeric(0)
		if (parents$n > 0) {
			chose=ncluster(n=parents$n, mu=mu)
			if (length(chose[[1]])>0){
				for (i in 1:length(chose[[1]])) {
					k=chose[[1]][i]
					n=chose[[2]][i]
					cluster <- rcluster(x0=parents$x[k], y0=parents$y[k], n=n,...)
					chos.off<- which(cluster$x>=win$xrange[1] & cluster$x<=win$xrange[2] 
									& cluster$y>=win$yrange[1] & cluster$y<=win$yrange[2])
					if (i==1) {
						offsp.x=cluster$x[chos.off]
						offsp.y=cluster$y[chos.off]
					}else{
						offsp.x=c(offsp.x,cluster$x[chos.off])
						offsp.y=c(offsp.y,cluster$y[chos.off])
					}
					if (i==1) pp.j=pp.j+1
					#parentid <- c(parentid, rep(i, cluster$n))
				}
				
			}
		
		
		if (pp.j==1){
			offsp.x.to=offsp.x
			offsp.y.to=offsp.y
		}
		if (pp.j>1){
			offsp.x.to=c(offsp.x.to,offsp.x)
			offsp.y.to=c(offsp.y.to,offsp.y)
		}
		}
		
		}
		result <- ppp(offsp.x.to, offsp.y.to, window = frame, check = FALSE)
		rm(offsp.x.to,offsp.y.to)
	}
    #attr(result, "parents") <- parents
    #attr(result, "parentid") <- parentid
    return(result)
}

rpoispp.my=function (lambda, lmax = NULL, win = owin(c(0, 1), c(0, 1)), 
    ...) 
{
    win <- if (is.im(lambda)) 
        rescue.rectangle(as.owin(lambda))
    else as.owin(win)
    if (is.numeric(lambda)) 
        return(runifpoispp(lambda, win))
    if (is.null(lmax)) {
        imag <- as.im(lambda, win, ...)
        summ <- summary(imag)
        lmax <- summ$max + 0.05 * diff(summ$range)
    }
    if (is.function(lambda)) {
        X <- runifpoispp(lmax, win)
        if (X$n == 0) 
            return(X)
        prob <- lambda(X$x, X$y, ...)/lmax
        u <- runif(X$n)
        retain <- (u <= prob)
        X <- X[retain, ]
        return(X)
    }
    if (is.im(lambda)) {
        X <- runifpoispp(lmax, win)
        if (X$n == 0) 
            return(X)
        prob <- lambda[X]/lmax
        u <- runif(X$n)
        retain <- (u <= prob)
        X <- X[retain, ]
		rm(prob);rm(retain);rm(u)
        return(X)
    }
    stop("'lambda' must be a constant, a function or an image")
}




thomas.estK.my=function (X, startpar = c(kappa = 1, sigma2 = 1), maxit=1e+4, lambda = NULL, 
    q = 1/4, p = 2, rmin = NULL, rmax = NULL) 
{
    dataname <- deparse(substitute(X))
    if (inherits(X, "fv")) {
        K <- X
    }
    else if (inherits(X, "ppp")) {
        K <- Kest(X)
        dataname <- paste("Kest(", dataname, ")", sep = "")
        lambda <- summary(X)$intensity
    }
    else stop("Unrecognised format for argument X")
    startpar <- check.named.vector(startpar, c("kappa", "sigma2"))
    theoret <- function(par, rvals) {
        if (any(par <= 0)) 
            return(rep(Inf, length(rvals)))
        pi * rvals^2 + (1 - exp(-rvals^2/(4 * par[2])))/par[1]
    }
    result <- mincontrast.my(K, theoret, startpar,maxit=maxit, ctrl = list(q = q, 
        p = p, rmin = rmin, rmax = rmax), fvlab = list(label = "Kfit(r)", 
        desc = "minimum contrast fit of Thomas process"), explain = list(dataname = dataname, 
        fname = "K", modelname = "Thomas process"))
    par <- result$par
    names(par) <- c("kappa", "sigma2")
    result$par <- par
    mu <- if (is.numeric(lambda) && length(lambda) == 1) 
        lambda/result$par[["kappa"]]
    else NA
    result$modelpar <- c(kappa = par[["kappa"]], sigma = sqrt(par[["sigma2"]]), 
        mu = mu)
    result$internal <- list(model = "Thomas")
    return(result)
}


mincontrast.my=function (observed, theoretical, startpar,maxit=1e+4,..., ctrl = list(q = 1/4, 
    p = 2, rmin = NULL, rmax = NULL), fvlab = list(label = NULL, 
    desc = "minimum contrast fit"), explain = list(dataname = NULL, 
    modelname = NULL, fname = NULL)) 
{
    verifyclass(observed, "fv")
    stopifnot(is.function(theoretical))
    if (!any("par" %in% names(formals(theoretical)))) 
        stop(paste("Theoretical function does not include an argument called", 
            sQuote("par")))
    ctrl <- resolve.defaults(ctrl, list(q = 1/4, p = 2, rmin = NULL, 
        rmax = NULL))
    fvlab <- resolve.defaults(fvlab, list(label = NULL, desc = "minimum contrast fit"))
    explain <- resolve.defaults(explain, list(dataname = NULL, 
        modelname = NULL, fname = NULL))
    rmin <- ctrl$rmin
    rmax <- ctrl$rmax
    if (!is.null(rmin) && !is.null(rmax)) 
        stopifnot(rmin < rmax && rmin >= 0)
    else {
        alim <- attr(observed, "alim")
        if (is.null(rmin)) 
            rmin <- alim[1]
        if (is.null(rmax)) 
            rmax <- alim[2]
    }
    argu <- attr(observed, "argu")
    rvals <- observed[[argu]]
    valu <- attr(observed, "valu")
    obs <- observed[[valu]]
    if (max(rvals) < rmax) 
        stop(paste("rmax=", signif(rmax, 4), "exceeds the range of available data", 
            "= [", signif(min(rvals), 4), ",", signif(max(rvals), 
                4), "]"))
    sub <- (rvals >= rmin) & (rvals <= rmax)
    rvals <- rvals[sub]
    obs <- obs[sub]
    obsq <- obs^(ctrl$q)
    objective <- function(par, obsq, theoretical, rvals, qq, 
        pp, rmin, rmax, ...) {
        theo <- theoretical(par = par, rvals)
        if (!is.vector(theo) || !is.numeric(theo)) 
            stop("theoretical function did not return a numeric vector")
        if (length(theo) != length(obs)) 
            stop("theoretical function did not return the correct number of values")
        discrep <- (abs(theo^qq - obsq))^pp
        return(sum(discrep))
    }
    minimum <- optim(startpar, fn = objective, obsq = obsq, theoretical = theoretical, 
        rvals = rvals, qq = ctrl$q, pp = ctrl$p, rmin = rmin, 
        rmax = rmax, maxit=maxit, ...)
    fittheo <- theoretical(minimum$par, rvals, ...)
    label <- fvlab$label
    desc <- fvlab$desc
    if (is.null(label)) 
        label <- paste("fit(", argu, ")", collapse = "")
    fitfv <- bind.fv(observed[sub, ], data.frame(fit = fittheo), 
        label, desc)
    result <- list(par = minimum$par, fit = fitfv, opt = minimum, 
        ctrl = list(p = ctrl$p, q = ctrl$q, rmin = rmin, rmax = rmax), 
        info = explain)
    class(result) <- c("minconfit", class(result))
    return(result)
}



# 2. sample function

plot.sample=function(data,subplot=c(20,20),plotdim=c(600,400),nsam=10){
# @ subplot: the size of subplot
# @ plotdim: the size of whole plot
# @ smd: sampling method, "regular" or "random"
# @ nsam: the number of sampling if the smd is equal to "random"
# @ raplace: logical.
# @ shape: the shape of subplot: circle or square
	plotdim=round(plotdim)
	subplot=round(subplot)
    point.x=numeric()
    point.y=numeric()
	
    point.x=runif(nsam,min=0,max=plotdim[1]-subplot[1])
    point.y=runif(nsam,min=0,max=plotdim[2]-subplot[2])
	
	S=numeric()
	if (!all(subplot==plotdim)){
    for (i in 1:nsam){
	   
        sample= data$gx>= point.x[i] & data$gx <= (point.x[i]+subplot[1]) & 
        data$gy>= point.y[i] & data$gy <= (point.y[i]+subplot[2])
		S[i]=length(unique(data$sp[sample]))
		
    }
	S.mean=mean(S,na.rm=T)
	S.var=var(S,na.rm=T)
	}else{
	S.mean=length(unique(data$sp))
	S.var=0
	}
return(c(S.mean,S.var))
}
